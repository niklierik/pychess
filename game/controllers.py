import scenes.gamescene
import game.color
import threading


class Controller:
    def __init__(self, color: game.color.PieceColor) -> None:
        self.color = color

    def init(self, scene: scenes.gamescene.GameScene) -> None:
        pass

    def update(self, scene: scenes.gamescene.GameScene) -> None:
        """
        Updates controller each tick if it is their turn
        """

    def dispose(self) -> None:
        pass


# The default player controller
class PlayerController(Controller):
    def update(self, scene) -> None:
        pass  # Handled by Board class


# Another player, whose moves coming from network
class NetworkController(Controller):
    pass


# AI whose moves are generated by stockfish
class AIController(Controller):
    def __init__(self, color: game.color.PieceColor, lvl: int):
        super().__init__(color)
        self._lvl = lvl
        self.run = False
        self.disposed = False
        self.scene: scenes.gamescene.GameScene = None  # type: ignore
        self.update_thread = threading.Thread(target=self.update_async, name="update")

    def init(self, scene):
        import chess.engine

        self.scene = scene
        self.engine = chess.engine.SimpleEngine.popen_uci("./stockfish")
        self.update_thread.start()

    @property
    def lvl(self):
        return self._lvl

    def update(self, scene) -> None:
        self.run = True

    def update_async(self):
        import chess.engine

        while True:
            if self.disposed:
                return
            if self.run and self.scene is not None:
                try:
                    # print("AI thinking")
                    result = self.engine.play(
                        self.scene.board.chess_board,
                        chess.engine.Limit(time=0.5, depth=20),
                    )
                    # print(f"Result: {result}")
                    if result.move is not None:
                        self.scene.board.make_move_uci(result.move.uci())
                    else:
                        self.scene.board.game_over()
                except BaseException as e:
                    print(e)
                    pass

                self.scene.board.turn_of = self.color.opposite()
                self.run = False

    def dispose(self):
        self.disposed = True


class InvalidAILvlException(ValueError):
    """Raised when the given AI level is invalid. (Less than 1 or greater than 5)"""
